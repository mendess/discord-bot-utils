use std::{collections::HashMap, option::Option, sync::OnceLock};

use super::events;
use crate::EventBus;
use serenity::client::EventHandler;
use serenity::gateway::ShardStageUpdateEvent;
use serenity::model::application::{CommandPermissions, Interaction};
use serenity::model::channel::{
    GuildChannel, Message, PartialGuildChannel, Reaction, StageInstance,
};
use serenity::model::event::{
    ChannelPinsUpdateEvent, GuildMemberUpdateEvent, GuildMembersChunkEvent,
    GuildScheduledEventUserAddEvent, GuildScheduledEventUserRemoveEvent, InviteCreateEvent,
    InviteDeleteEvent, MessageUpdateEvent, ResumedEvent, ThreadListSyncEvent,
    ThreadMembersUpdateEvent, TypingStartEvent, VoiceServerUpdateEvent,
};
use serenity::model::gateway::{Presence, Ready};
use serenity::model::guild::{
    automod::{ActionExecution, Rule},
    Emoji, Guild, Integration, Member, PartialGuild, Role, ScheduledEvent, ThreadMember,
    UnavailableGuild,
};
use serenity::model::id::{ChannelId, EmojiId, GuildId, MessageId, RoleId, StickerId, UserId};
use serenity::model::prelude::{ApplicationId, IntegrationId};
use serenity::model::sticker::Sticker;
use serenity::model::user::{CurrentUser, User};
use serenity::model::voice::VoiceState;

#[derive(Debug, Default, Clone, Copy)]
pub struct HandlerOptions<S> {
    pub state: S,
    pub include_bot_generated_events: bool,
}

#[derive(Clone)]
pub struct Handler<'s, S> {
    bot_id: OnceLock<UserId>,
    bus: &'s EventBus<S>,
    options: HandlerOptions<S>,
}

impl<'s, S> Handler<'s, S> {
    /// The bot_id, if passed, will serve to filter a few events that are generated by bot actions
    /// such as new messages and reactions.
    pub fn new(bus: &'s EventBus<S>, options: HandlerOptions<S>) -> Self {
        Self {
            bot_id: OnceLock::new(),
            bus,
            options,
        }
    }
}

pub struct Context<S> {
    pub serenity: serenity::client::Context,
    pub state: S,
}

#[serenity::async_trait]
impl<'s, S: Send + Sync + Clone + 'static> EventHandler for Handler<'s, S> {
    async fn command_permissions_update(
        &self,
        ctx: serenity::client::Context,
        permission: CommandPermissions,
    ) {
        self.bus
            .publish::<events::ApplicationCommandPermissionUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                permission,
            )
            .await;
    }

    async fn auto_moderation_rule_create(&self, ctx: serenity::client::Context, rule: Rule) {
        self.bus
            .publish::<events::AutoModerationRuleCreate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                rule,
            )
            .await;
    }

    async fn auto_moderation_rule_update(&self, ctx: serenity::client::Context, rule: Rule) {
        self.bus
            .publish::<events::AutoModerationRuleUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                rule,
            )
            .await;
    }

    async fn auto_moderation_rule_delete(&self, ctx: serenity::client::Context, rule: Rule) {
        self.bus
            .publish::<events::AutoModerationRuleDelete>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                rule,
            )
            .await;
    }

    async fn auto_moderation_action_execution(
        &self,
        ctx: serenity::client::Context,
        execution: ActionExecution,
    ) {
        self.bus
            .publish::<events::AutoModerationActionExecution>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                execution,
            )
            .await;
    }

    #[cfg(feature = "serenity_cache")]
    async fn cache_ready(&self, ctx: serenity::client::Context, guilds: Vec<GuildId>) {
        self.bus
            .publish::<events::CacheReady>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                guilds,
            )
            .await;
    }

    async fn channel_create(&self, ctx: serenity::client::Context, channel: GuildChannel) {
        self.bus
            .publish_with::<events::ChannelCreate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                || channel.clone(),
            )
            .await
    }

    async fn category_create(&self, ctx: serenity::client::Context, category: GuildChannel) {
        self.bus
            .publish_with::<events::CategoryCreate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                || category.clone(),
            )
            .await
    }

    async fn category_delete(&self, ctx: serenity::client::Context, category: GuildChannel) {
        self.bus
            .publish_with::<events::CategoryDelete>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                || category.clone(),
            )
            .await;
    }

    async fn channel_delete(
        &self,
        ctx: serenity::client::Context,
        channel: GuildChannel,
        messages: Option<Vec<Message>>,
    ) {
        self.bus
            .publish::<events::ChannelDelete>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::ChannelDelete {
                    channel: channel.clone(),
                    messages: messages.clone(),
                },
            )
            .await;
    }

    async fn channel_pins_update(
        &self,
        ctx: serenity::client::Context,
        pin: ChannelPinsUpdateEvent,
    ) {
        self.bus
            .publish::<events::ChannelPinsUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                pin,
            )
            .await;
    }

    async fn channel_update(
        &self,
        ctx: serenity::client::Context,
        old: Option<GuildChannel>,
        new: GuildChannel,
    ) {
        self.bus
            .publish::<events::ChannelUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::ChannelUpdate { old, new },
            )
            .await;
    }

    async fn guild_ban_addition(
        &self,
        ctx: serenity::client::Context,
        guild_id: GuildId,
        banned_user: User,
    ) {
        self.bus
            .publish::<events::GuildBanAddition>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::GuildBanAddition {
                    guild_id,
                    banned_user,
                },
            )
            .await;
    }

    async fn guild_ban_removal(
        &self,
        ctx: serenity::client::Context,
        guild_id: GuildId,
        unbanned_user: User,
    ) {
        self.bus
            .publish::<events::GuildBanRemoval>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::GuildBanRemoval {
                    guild_id,
                    unbanned_user,
                },
            )
            .await;
    }

    async fn guild_create(
        &self,
        ctx: serenity::client::Context,
        guild: Guild,
        is_new: Option<bool>,
    ) {
        self.bus
            .publish::<events::GuildCreate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::GuildCreate { guild, is_new },
            )
            .await;
    }

    async fn guild_delete(
        &self,
        ctx: serenity::client::Context,
        incomplete: UnavailableGuild,
        full: Option<Guild>,
    ) {
        self.bus
            .publish::<events::GuildDelete>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::GuildDelete { incomplete, full },
            )
            .await;
    }

    async fn guild_emojis_update(
        &self,
        ctx: serenity::client::Context,
        guild_id: GuildId,
        current_state: HashMap<EmojiId, Emoji>,
    ) {
        self.bus
            .publish::<events::GuildEmojisUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::GuildEmojisUpdate {
                    guild_id,
                    current_state,
                },
            )
            .await;
    }

    async fn guild_integrations_update(&self, ctx: serenity::client::Context, guild_id: GuildId) {
        self.bus
            .publish::<events::GuildIntegrationsUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                guild_id,
            )
            .await;
    }

    async fn guild_member_addition(&self, ctx: serenity::client::Context, new_member: Member) {
        self.bus
            .publish::<events::GuildMemberAddition>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                new_member,
            )
            .await;
    }

    async fn guild_member_removal(
        &self,
        ctx: serenity::client::Context,
        guild_id: GuildId,
        user: User,
        member_data_if_available: Option<Member>,
    ) {
        self.bus
            .publish::<events::GuildMemberRemoval>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::GuildMemberRemoval {
                    guild_id,
                    user,
                    member_data_if_available,
                },
            )
            .await;
    }

    async fn guild_member_update(
        &self,
        ctx: serenity::client::Context,
        old_if_available: Option<Member>,
        new: Option<Member>,
        event: GuildMemberUpdateEvent,
    ) {
        self.bus
            .publish::<events::GuildMemberUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::GuildMemberUpdate {
                    old_if_available,
                    new,
                    event,
                },
            )
            .await;
    }

    async fn guild_members_chunk(
        &self,
        ctx: serenity::client::Context,
        chunk: GuildMembersChunkEvent,
    ) {
        self.bus
            .publish::<events::GuildMembersChunk>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                chunk,
            )
            .await;
    }

    async fn guild_role_create(&self, ctx: serenity::client::Context, new: Role) {
        self.bus
            .publish::<events::GuildRoleCreate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                new,
            )
            .await;
    }

    async fn guild_role_delete(
        &self,
        ctx: serenity::client::Context,
        guild_id: GuildId,
        removed_role_id: RoleId,
        removed_role_data_if_available: Option<Role>,
    ) {
        self.bus
            .publish::<events::GuildRoleDelete>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::GuildRoleDelete {
                    guild_id,
                    removed_role_id,
                    removed_role_data_if_available,
                },
            )
            .await;
    }

    async fn guild_role_update(
        &self,
        ctx: serenity::client::Context,
        old_data_if_available: Option<Role>,
        new: Role,
    ) {
        self.bus
            .publish::<events::GuildRoleUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::GuildRoleUpdate {
                    old_data_if_available,
                    new,
                },
            )
            .await;
    }

    async fn guild_stickers_update(
        &self,
        ctx: serenity::client::Context,
        guild_id: GuildId,
        current_state: HashMap<StickerId, Sticker>,
    ) {
        self.bus
            .publish::<events::GuildStickersUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::GuildStickersUpdate {
                    guild_id,
                    current_state,
                },
            )
            .await;
    }

    async fn guild_update(
        &self,
        ctx: serenity::client::Context,
        old_data_if_available: Option<Guild>,
        new_but_incomplete: PartialGuild,
    ) {
        self.bus
            .publish::<events::GuildUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::GuildUpdate {
                    old_data_if_available,
                    new_but_incomplete,
                },
            )
            .await;
    }

    async fn invite_create(&self, ctx: serenity::client::Context, data: InviteCreateEvent) {
        if self.options.include_bot_generated_events
            || data.inviter.as_ref().map(|u| u.id) != self.bot_id.get().copied()
        {
            self.bus
                .publish::<events::InviteCreate>(
                    Context {
                        serenity: ctx,
                        state: self.options.state.clone(),
                    },
                    data,
                )
                .await;
        }
    }

    async fn invite_delete(&self, ctx: serenity::client::Context, data: InviteDeleteEvent) {
        self.bus
            .publish::<events::InviteDelete>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                data,
            )
            .await;
    }

    async fn message(&self, ctx: serenity::client::Context, new_message: Message) {
        if self.options.include_bot_generated_events
            || Some(new_message.author.id) != self.bot_id.get().copied()
        {
            self.bus
                .publish::<events::Message>(
                    Context {
                        serenity: ctx,
                        state: self.options.state.clone(),
                    },
                    new_message,
                )
                .await;
        }
    }

    async fn message_delete(
        &self,
        ctx: serenity::client::Context,
        channel_id: ChannelId,
        deleted_message_id: MessageId,
        guild_id: Option<GuildId>,
    ) {
        self.bus
            .publish::<events::MessageDelete>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::MessageDelete {
                    channel_id,
                    deleted_message_id,
                    guild_id,
                },
            )
            .await;
    }

    async fn message_delete_bulk(
        &self,
        ctx: serenity::client::Context,
        channel_id: ChannelId,
        multiple_deleted_messages_ids: Vec<MessageId>,
        guild_id: Option<GuildId>,
    ) {
        self.bus
            .publish::<events::MessageDeleteBulk>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::MessageDeleteBulk {
                    channel_id,
                    multiple_deleted_messages_ids,
                    guild_id,
                },
            )
            .await;
    }

    async fn message_update(
        &self,
        ctx: serenity::client::Context,
        old_if_available: Option<Message>,
        new: Option<Message>,
        event: MessageUpdateEvent,
    ) {
        if self.options.include_bot_generated_events
            || event.author.as_ref().map(|u| u.id) != self.bot_id.get().copied()
        {
            self.bus
                .publish::<events::MessageUpdate>(
                    Context {
                        serenity: ctx,
                        state: self.options.state.clone(),
                    },
                    events::MessageUpdate {
                        old_if_available,
                        new,
                        event,
                    },
                )
                .await;
        }
    }

    async fn reaction_add(&self, ctx: serenity::client::Context, add_reaction: Reaction) {
        if self.options.include_bot_generated_events
            || add_reaction.user_id != self.bot_id.get().copied()
        {
            self.bus
                .publish::<events::ReactionAdd>(
                    Context {
                        serenity: ctx,
                        state: self.options.state.clone(),
                    },
                    add_reaction,
                )
                .await;
        }
    }

    async fn reaction_remove(&self, ctx: serenity::client::Context, remove_reaction: Reaction) {
        if self.options.include_bot_generated_events
            || remove_reaction.user_id != self.bot_id.get().copied()
        {
            self.bus
                .publish::<events::ReactionRemove>(
                    Context {
                        serenity: ctx,
                        state: self.options.state.clone(),
                    },
                    remove_reaction,
                )
                .await;
        }
    }

    async fn reaction_remove_all(
        &self,
        ctx: serenity::client::Context,
        channel_id: ChannelId,
        removed_from_message_id: MessageId,
    ) {
        self.bus
            .publish::<events::ReactionRemoveAll>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::ReactionRemoveAll {
                    channel_id,
                    removed_from_message_id,
                },
            )
            .await;
    }

    async fn presence_replace(&self, ctx: serenity::client::Context, presence: Vec<Presence>) {
        self.bus
            .publish::<events::PresenceReplace>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                presence,
            )
            .await;
    }

    async fn presence_update(&self, ctx: serenity::client::Context, new_data: Presence) {
        self.bus
            .publish::<events::PresenceUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                new_data,
            )
            .await;
    }

    async fn ready(&self, ctx: serenity::client::Context, ready: Ready) {
        let _ = self.bot_id.set(ready.user.id);
        self.bus
            .publish::<events::Ready>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                ready,
            )
            .await;
    }

    async fn resume(&self, ctx: serenity::client::Context, event: ResumedEvent) {
        self.bus
            .publish::<events::Resume>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                event,
            )
            .await;
    }

    async fn shard_stage_update(
        &self,
        ctx: serenity::client::Context,
        event: ShardStageUpdateEvent,
    ) {
        self.bus
            .publish::<events::ShardStageUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                event,
            )
            .await;
    }

    async fn typing_start(&self, ctx: serenity::client::Context, event: TypingStartEvent) {
        self.bus
            .publish::<events::TypingStart>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                event,
            )
            .await;
    }

    async fn user_update(
        &self,
        ctx: serenity::client::Context,
        old_data: Option<CurrentUser>,
        new: CurrentUser,
    ) {
        self.bus
            .publish::<events::UserUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::UserUpdate { old_data, new },
            )
            .await
    }

    async fn voice_server_update(
        &self,
        ctx: serenity::client::Context,
        event: VoiceServerUpdateEvent,
    ) {
        self.bus
            .publish::<events::VoiceServerUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                event,
            )
            .await;
    }

    async fn voice_state_update(
        &self,
        ctx: serenity::client::Context,
        old: Option<VoiceState>,
        new: VoiceState,
    ) {
        self.bus
            .publish::<events::VoiceStateUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::VoiceStateUpdate { new, old },
            )
            .await;
    }

    async fn webhook_update(
        &self,
        ctx: serenity::client::Context,
        guild_id: GuildId,
        belongs_to_channel_id: ChannelId,
    ) {
        self.bus
            .publish::<events::WebhookUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::WebhookUpdate {
                    guild_id,
                    belongs_to_channel_id,
                },
            )
            .await;
    }

    async fn interaction_create(&self, ctx: serenity::client::Context, interaction: Interaction) {
        self.bus
            .publish::<events::InteractionCreate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                interaction,
            )
            .await;
    }

    async fn integration_create(&self, ctx: serenity::client::Context, integration: Integration) {
        self.bus
            .publish::<events::IntegrationCreate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                integration,
            )
            .await;
    }

    async fn integration_update(&self, ctx: serenity::client::Context, integration: Integration) {
        self.bus
            .publish::<events::IntegrationUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                integration,
            )
            .await;
    }

    async fn integration_delete(
        &self,
        ctx: serenity::client::Context,
        integration_id: IntegrationId,
        guild_id: GuildId,
        application_id: Option<ApplicationId>,
    ) {
        self.bus
            .publish::<events::IntegrationDelete>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::IntegrationDelete {
                    integration_id,
                    guild_id,
                    application_id,
                },
            )
            .await;
    }

    async fn stage_instance_create(
        &self,
        ctx: serenity::client::Context,
        stage_instance: StageInstance,
    ) {
        self.bus
            .publish::<events::StageInstanceCreate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                stage_instance,
            )
            .await;
    }

    async fn stage_instance_update(
        &self,
        ctx: serenity::client::Context,
        stage_instance: StageInstance,
    ) {
        self.bus
            .publish::<events::StageInstanceUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                stage_instance,
            )
            .await;
    }

    async fn stage_instance_delete(
        &self,
        ctx: serenity::client::Context,
        stage_instance: StageInstance,
    ) {
        self.bus
            .publish::<events::StageInstanceDelete>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                stage_instance,
            )
            .await;
    }

    async fn thread_create(&self, ctx: serenity::client::Context, thread: GuildChannel) {
        self.bus
            .publish::<events::ThreadCreate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                thread,
            )
            .await;
    }

    async fn thread_update(
        &self,
        ctx: serenity::client::Context,
        old: Option<GuildChannel>,
        new: GuildChannel,
    ) {
        self.bus
            .publish::<events::ThreadUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::ThreadUpdate { old, new },
            )
            .await;
    }

    async fn thread_delete(
        &self,
        ctx: serenity::client::Context,
        thread: PartialGuildChannel,
        full_thread_data: Option<GuildChannel>,
    ) {
        self.bus
            .publish::<events::ThreadDelete>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                events::ThreadDelete {
                    thread,
                    full_thread_data,
                },
            )
            .await
    }

    async fn thread_list_sync(
        &self,
        ctx: serenity::client::Context,
        thread_list_sync: ThreadListSyncEvent,
    ) {
        self.bus
            .publish::<events::ThreadListSync>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                thread_list_sync,
            )
            .await
    }

    async fn thread_member_update(
        &self,
        ctx: serenity::client::Context,
        thread_member: ThreadMember,
    ) {
        self.bus
            .publish::<events::ThreadMemberUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                thread_member,
            )
            .await
    }

    async fn thread_members_update(
        &self,
        ctx: serenity::client::Context,
        thread_members_update: ThreadMembersUpdateEvent,
    ) {
        self.bus
            .publish::<events::ThreadMembersUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                thread_members_update,
            )
            .await
    }

    async fn guild_scheduled_event_create(
        &self,
        ctx: serenity::client::Context,
        event: ScheduledEvent,
    ) {
        self.bus
            .publish::<events::GuildScheduledEventCreate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                event,
            )
            .await
    }

    async fn guild_scheduled_event_update(
        &self,
        ctx: serenity::client::Context,
        event: ScheduledEvent,
    ) {
        self.bus
            .publish::<events::GuildScheduledEventUpdate>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                event,
            )
            .await
    }

    async fn guild_scheduled_event_delete(
        &self,
        ctx: serenity::client::Context,
        event: ScheduledEvent,
    ) {
        self.bus
            .publish::<events::GuildScheduledEventDelete>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                event,
            )
            .await
    }

    async fn guild_scheduled_event_user_add(
        &self,
        ctx: serenity::client::Context,
        subscribed: GuildScheduledEventUserAddEvent,
    ) {
        self.bus
            .publish::<events::GuildScheduledEventUserAdd>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                subscribed,
            )
            .await
    }

    async fn guild_scheduled_event_user_remove(
        &self,
        ctx: serenity::client::Context,
        unsubscribed: GuildScheduledEventUserRemoveEvent,
    ) {
        self.bus
            .publish::<events::GuildScheduledEventUserRemove>(
                Context {
                    serenity: ctx,
                    state: self.options.state.clone(),
                },
                unsubscribed,
            )
            .await
    }
}
